// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	AgentRegistration
	AgentPrivateToken
	AgentConfiguration
	CommandFinish
	Help
	RemoteCommand
	Empty
	CommandRequest
	LogEntry
	ErrorLogEntry
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AgentRegistration struct {
	Token    string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
	Hostname string `protobuf:"bytes,2,opt,name=Hostname" json:"Hostname,omitempty"`
}

func (m *AgentRegistration) Reset()                    { *m = AgentRegistration{} }
func (m *AgentRegistration) String() string            { return proto.CompactTextString(m) }
func (*AgentRegistration) ProtoMessage()               {}
func (*AgentRegistration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AgentRegistration) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AgentRegistration) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

type AgentPrivateToken struct {
	Token string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
}

func (m *AgentPrivateToken) Reset()                    { *m = AgentPrivateToken{} }
func (m *AgentPrivateToken) String() string            { return proto.CompactTextString(m) }
func (*AgentPrivateToken) ProtoMessage()               {}
func (*AgentPrivateToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AgentPrivateToken) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type AgentConfiguration struct {
	Token    string                    `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
	Labels   map[string]string         `protobuf:"bytes,3,rep,name=Labels" json:"Labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Commands map[string]*RemoteCommand `protobuf:"bytes,2,rep,name=commands" json:"commands,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AgentConfiguration) Reset()                    { *m = AgentConfiguration{} }
func (m *AgentConfiguration) String() string            { return proto.CompactTextString(m) }
func (*AgentConfiguration) ProtoMessage()               {}
func (*AgentConfiguration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AgentConfiguration) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AgentConfiguration) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *AgentConfiguration) GetCommands() map[string]*RemoteCommand {
	if m != nil {
		return m.Commands
	}
	return nil
}

type CommandFinish struct {
	JobID  uint64 `protobuf:"varint,1,opt,name=jobID" json:"jobID,omitempty"`
	Status string `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Error  string `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
}

func (m *CommandFinish) Reset()                    { *m = CommandFinish{} }
func (m *CommandFinish) String() string            { return proto.CompactTextString(m) }
func (*CommandFinish) ProtoMessage()               {}
func (*CommandFinish) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CommandFinish) GetJobID() uint64 {
	if m != nil {
		return m.JobID
	}
	return 0
}

func (m *CommandFinish) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *CommandFinish) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Help struct {
	Summary string   `protobuf:"bytes,1,opt,name=Summary" json:"Summary,omitempty"`
	Args    []string `protobuf:"bytes,2,rep,name=Args" json:"Args,omitempty"`
}

func (m *Help) Reset()                    { *m = Help{} }
func (m *Help) String() string            { return proto.CompactTextString(m) }
func (*Help) ProtoMessage()               {}
func (*Help) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Help) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *Help) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

type RemoteCommand struct {
	Timeout         int64             `protobuf:"varint,1,opt,name=Timeout" json:"Timeout,omitempty"`
	AuthStrategy    string            `protobuf:"bytes,2,opt,name=AuthStrategy" json:"AuthStrategy,omitempty"`
	AllowedGroups   []string          `protobuf:"bytes,3,rep,name=AllowedGroups" json:"AllowedGroups,omitempty"`
	ChannelStrategy string            `protobuf:"bytes,4,opt,name=ChannelStrategy" json:"ChannelStrategy,omitempty"`
	AllowedChannels []string          `protobuf:"bytes,5,rep,name=AllowedChannels" json:"AllowedChannels,omitempty"`
	Templates       map[string]string `protobuf:"bytes,6,rep,name=Templates" json:"Templates,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Help            *Help             `protobuf:"bytes,7,opt,name=help" json:"help,omitempty"`
}

func (m *RemoteCommand) Reset()                    { *m = RemoteCommand{} }
func (m *RemoteCommand) String() string            { return proto.CompactTextString(m) }
func (*RemoteCommand) ProtoMessage()               {}
func (*RemoteCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RemoteCommand) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RemoteCommand) GetAuthStrategy() string {
	if m != nil {
		return m.AuthStrategy
	}
	return ""
}

func (m *RemoteCommand) GetAllowedGroups() []string {
	if m != nil {
		return m.AllowedGroups
	}
	return nil
}

func (m *RemoteCommand) GetChannelStrategy() string {
	if m != nil {
		return m.ChannelStrategy
	}
	return ""
}

func (m *RemoteCommand) GetAllowedChannels() []string {
	if m != nil {
		return m.AllowedChannels
	}
	return nil
}

func (m *RemoteCommand) GetTemplates() map[string]string {
	if m != nil {
		return m.Templates
	}
	return nil
}

func (m *RemoteCommand) GetHelp() *Help {
	if m != nil {
		return m.Help
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type CommandRequest struct {
	Command     string   `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
	Args        []string `protobuf:"bytes,2,rep,name=args" json:"args,omitempty"`
	Username    string   `protobuf:"bytes,3,opt,name=username" json:"username,omitempty"`
	UserID      string   `protobuf:"bytes,4,opt,name=userID" json:"userID,omitempty"`
	UserLink    string   `protobuf:"bytes,5,opt,name=userLink" json:"userLink,omitempty"`
	Channel     string   `protobuf:"bytes,6,opt,name=channel" json:"channel,omitempty"`
	ChannelID   string   `protobuf:"bytes,7,opt,name=channelID" json:"channelID,omitempty"`
	ChannelLink string   `protobuf:"bytes,8,opt,name=channelLink" json:"channelLink,omitempty"`
	IsIM        bool     `protobuf:"varint,9,opt,name=isIM" json:"isIM,omitempty"`
	JobID       uint64   `protobuf:"varint,10,opt,name=jobID" json:"jobID,omitempty"`
}

func (m *CommandRequest) Reset()                    { *m = CommandRequest{} }
func (m *CommandRequest) String() string            { return proto.CompactTextString(m) }
func (*CommandRequest) ProtoMessage()               {}
func (*CommandRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CommandRequest) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *CommandRequest) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *CommandRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *CommandRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *CommandRequest) GetUserLink() string {
	if m != nil {
		return m.UserLink
	}
	return ""
}

func (m *CommandRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *CommandRequest) GetChannelID() string {
	if m != nil {
		return m.ChannelID
	}
	return ""
}

func (m *CommandRequest) GetChannelLink() string {
	if m != nil {
		return m.ChannelLink
	}
	return ""
}

func (m *CommandRequest) GetIsIM() bool {
	if m != nil {
		return m.IsIM
	}
	return false
}

func (m *CommandRequest) GetJobID() uint64 {
	if m != nil {
		return m.JobID
	}
	return 0
}

type LogEntry struct {
	JobID uint64 `protobuf:"varint,1,opt,name=jobID" json:"jobID,omitempty"`
	Line  string `protobuf:"bytes,2,opt,name=line" json:"line,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *LogEntry) GetJobID() uint64 {
	if m != nil {
		return m.JobID
	}
	return 0
}

func (m *LogEntry) GetLine() string {
	if m != nil {
		return m.Line
	}
	return ""
}

type ErrorLogEntry struct {
	JobID uint64 `protobuf:"varint,1,opt,name=jobID" json:"jobID,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *ErrorLogEntry) Reset()                    { *m = ErrorLogEntry{} }
func (m *ErrorLogEntry) String() string            { return proto.CompactTextString(m) }
func (*ErrorLogEntry) ProtoMessage()               {}
func (*ErrorLogEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ErrorLogEntry) GetJobID() uint64 {
	if m != nil {
		return m.JobID
	}
	return 0
}

func (m *ErrorLogEntry) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func init() {
	proto.RegisterType((*AgentRegistration)(nil), "api.AgentRegistration")
	proto.RegisterType((*AgentPrivateToken)(nil), "api.AgentPrivateToken")
	proto.RegisterType((*AgentConfiguration)(nil), "api.AgentConfiguration")
	proto.RegisterType((*CommandFinish)(nil), "api.CommandFinish")
	proto.RegisterType((*Help)(nil), "api.Help")
	proto.RegisterType((*RemoteCommand)(nil), "api.RemoteCommand")
	proto.RegisterType((*Empty)(nil), "api.Empty")
	proto.RegisterType((*CommandRequest)(nil), "api.CommandRequest")
	proto.RegisterType((*LogEntry)(nil), "api.LogEntry")
	proto.RegisterType((*ErrorLogEntry)(nil), "api.ErrorLogEntry")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Registration service

type RegistrationClient interface {
	Register(ctx context.Context, in *AgentRegistration, opts ...grpc.CallOption) (*AgentPrivateToken, error)
}

type registrationClient struct {
	cc *grpc.ClientConn
}

func NewRegistrationClient(cc *grpc.ClientConn) RegistrationClient {
	return &registrationClient{cc}
}

func (c *registrationClient) Register(ctx context.Context, in *AgentRegistration, opts ...grpc.CallOption) (*AgentPrivateToken, error) {
	out := new(AgentPrivateToken)
	err := grpc.Invoke(ctx, "/api.Registration/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Registration service

type RegistrationServer interface {
	Register(context.Context, *AgentRegistration) (*AgentPrivateToken, error)
}

func RegisterRegistrationServer(s *grpc.Server, srv RegistrationServer) {
	s.RegisterService(&_Registration_serviceDesc, srv)
}

func _Registration_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistrationServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Registration/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistrationServer).Register(ctx, req.(*AgentRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

var _Registration_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Registration",
	HandlerType: (*RegistrationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Registration_Register_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// Client API for CommandPipeline service

type CommandPipelineClient interface {
	RegisterAgent(ctx context.Context, in *AgentConfiguration, opts ...grpc.CallOption) (CommandPipeline_RegisterAgentClient, error)
	Finish(ctx context.Context, in *CommandFinish, opts ...grpc.CallOption) (*Empty, error)
}

type commandPipelineClient struct {
	cc *grpc.ClientConn
}

func NewCommandPipelineClient(cc *grpc.ClientConn) CommandPipelineClient {
	return &commandPipelineClient{cc}
}

func (c *commandPipelineClient) RegisterAgent(ctx context.Context, in *AgentConfiguration, opts ...grpc.CallOption) (CommandPipeline_RegisterAgentClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CommandPipeline_serviceDesc.Streams[0], c.cc, "/api.CommandPipeline/RegisterAgent", opts...)
	if err != nil {
		return nil, err
	}
	x := &commandPipelineRegisterAgentClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CommandPipeline_RegisterAgentClient interface {
	Recv() (*CommandRequest, error)
	grpc.ClientStream
}

type commandPipelineRegisterAgentClient struct {
	grpc.ClientStream
}

func (x *commandPipelineRegisterAgentClient) Recv() (*CommandRequest, error) {
	m := new(CommandRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *commandPipelineClient) Finish(ctx context.Context, in *CommandFinish, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.CommandPipeline/Finish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CommandPipeline service

type CommandPipelineServer interface {
	RegisterAgent(*AgentConfiguration, CommandPipeline_RegisterAgentServer) error
	Finish(context.Context, *CommandFinish) (*Empty, error)
}

func RegisterCommandPipelineServer(s *grpc.Server, srv CommandPipelineServer) {
	s.RegisterService(&_CommandPipeline_serviceDesc, srv)
}

func _CommandPipeline_RegisterAgent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AgentConfiguration)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CommandPipelineServer).RegisterAgent(m, &commandPipelineRegisterAgentServer{stream})
}

type CommandPipeline_RegisterAgentServer interface {
	Send(*CommandRequest) error
	grpc.ServerStream
}

type commandPipelineRegisterAgentServer struct {
	grpc.ServerStream
}

func (x *commandPipelineRegisterAgentServer) Send(m *CommandRequest) error {
	return x.ServerStream.SendMsg(m)
}

func _CommandPipeline_Finish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandFinish)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandPipelineServer).Finish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CommandPipeline/Finish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandPipelineServer).Finish(ctx, req.(*CommandFinish))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommandPipeline_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.CommandPipeline",
	HandlerType: (*CommandPipelineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Finish",
			Handler:    _CommandPipeline_Finish_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RegisterAgent",
			Handler:       _CommandPipeline_RegisterAgent_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

// Client API for LogWriter service

type LogWriterClient interface {
	NewWriter(ctx context.Context, opts ...grpc.CallOption) (LogWriter_NewWriterClient, error)
	SetError(ctx context.Context, in *ErrorLogEntry, opts ...grpc.CallOption) (*Empty, error)
}

type logWriterClient struct {
	cc *grpc.ClientConn
}

func NewLogWriterClient(cc *grpc.ClientConn) LogWriterClient {
	return &logWriterClient{cc}
}

func (c *logWriterClient) NewWriter(ctx context.Context, opts ...grpc.CallOption) (LogWriter_NewWriterClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_LogWriter_serviceDesc.Streams[0], c.cc, "/api.LogWriter/NewWriter", opts...)
	if err != nil {
		return nil, err
	}
	x := &logWriterNewWriterClient{stream}
	return x, nil
}

type LogWriter_NewWriterClient interface {
	Send(*LogEntry) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type logWriterNewWriterClient struct {
	grpc.ClientStream
}

func (x *logWriterNewWriterClient) Send(m *LogEntry) error {
	return x.ClientStream.SendMsg(m)
}

func (x *logWriterNewWriterClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *logWriterClient) SetError(ctx context.Context, in *ErrorLogEntry, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.LogWriter/SetError", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for LogWriter service

type LogWriterServer interface {
	NewWriter(LogWriter_NewWriterServer) error
	SetError(context.Context, *ErrorLogEntry) (*Empty, error)
}

func RegisterLogWriterServer(s *grpc.Server, srv LogWriterServer) {
	s.RegisterService(&_LogWriter_serviceDesc, srv)
}

func _LogWriter_NewWriter_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LogWriterServer).NewWriter(&logWriterNewWriterServer{stream})
}

type LogWriter_NewWriterServer interface {
	SendAndClose(*Empty) error
	Recv() (*LogEntry, error)
	grpc.ServerStream
}

type logWriterNewWriterServer struct {
	grpc.ServerStream
}

func (x *logWriterNewWriterServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *logWriterNewWriterServer) Recv() (*LogEntry, error) {
	m := new(LogEntry)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _LogWriter_SetError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ErrorLogEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogWriterServer).SetError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.LogWriter/SetError",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogWriterServer).SetError(ctx, req.(*ErrorLogEntry))
	}
	return interceptor(ctx, in, info, handler)
}

var _LogWriter_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.LogWriter",
	HandlerType: (*LogWriterServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SetError",
			Handler:    _LogWriter_SetError_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NewWriter",
			Handler:       _LogWriter_NewWriter_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 713 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xdd, 0x6e, 0xd3, 0x4c,
	0x10, 0x6d, 0x9c, 0x9f, 0xda, 0x93, 0xa6, 0xfd, 0xbe, 0x05, 0x15, 0xcb, 0x02, 0x29, 0x18, 0x90,
	0x42, 0x85, 0x22, 0x14, 0x7a, 0x01, 0xb4, 0x12, 0x8a, 0xda, 0x40, 0x23, 0x05, 0xa8, 0x9c, 0x4a,
	0x5c, 0xbb, 0x74, 0x71, 0x96, 0xda, 0x5e, 0x63, 0xaf, 0x5b, 0xe5, 0x8e, 0x67, 0xe0, 0x61, 0x78,
	0x23, 0xde, 0x03, 0xed, 0xec, 0xda, 0xb1, 0xfb, 0x03, 0xe2, 0x6e, 0xce, 0x78, 0xce, 0xd9, 0xc9,
	0xcc, 0xd9, 0x0d, 0x58, 0x7e, 0xc2, 0x86, 0x49, 0xca, 0x05, 0x27, 0x4d, 0x3f, 0x61, 0xee, 0x04,
	0xfe, 0x1f, 0x07, 0x34, 0x16, 0x1e, 0x0d, 0x58, 0x26, 0x52, 0x5f, 0x30, 0x1e, 0x93, 0xbb, 0xd0,
	0x3e, 0xe1, 0xe7, 0x34, 0xb6, 0x1b, 0xfd, 0xc6, 0xc0, 0xf2, 0x14, 0x20, 0x0e, 0x98, 0x47, 0x3c,
	0x13, 0xb1, 0x1f, 0x51, 0xdb, 0xc0, 0x0f, 0x25, 0x76, 0x9f, 0x6a, 0x99, 0xe3, 0x94, 0x5d, 0xf8,
	0x82, 0x2a, 0xc2, 0x8d, 0x32, 0xee, 0x4f, 0x03, 0x08, 0xd6, 0x1e, 0xf0, 0xf8, 0x0b, 0x0b, 0xf2,
	0x3f, 0x9e, 0xb9, 0x07, 0x9d, 0x99, 0x7f, 0x4a, 0xc3, 0xcc, 0x6e, 0xf6, 0x9b, 0x83, 0xee, 0xe8,
	0xd1, 0x50, 0xf6, 0x7f, 0x9d, 0x3e, 0x54, 0x55, 0x93, 0x58, 0xa4, 0x4b, 0x4f, 0x53, 0xc8, 0x18,
	0xcc, 0xcf, 0x3c, 0x8a, 0xfc, 0xf8, 0x2c, 0xb3, 0x0d, 0xa4, 0x3f, 0xb9, 0x8d, 0x7e, 0xa0, 0xeb,
	0x94, 0x40, 0x49, 0x73, 0x5e, 0x41, 0xb7, 0xa2, 0x4c, 0xfe, 0x83, 0xe6, 0x39, 0x5d, 0xea, 0x16,
	0x65, 0x28, 0xdb, 0xbe, 0xf0, 0xc3, 0xbc, 0x98, 0x88, 0x02, 0xaf, 0x8d, 0x97, 0x0d, 0xe7, 0x23,
	0xf4, 0x6a, 0xaa, 0x37, 0x90, 0x07, 0x55, 0x72, 0x77, 0x44, 0xb0, 0x3b, 0x8f, 0x46, 0x5c, 0x50,
	0x4d, 0xad, 0x08, 0xba, 0xf3, 0x52, 0xf0, 0x2d, 0x8b, 0x59, 0xb6, 0x90, 0x67, 0x7f, 0xe5, 0xa7,
	0xd3, 0x43, 0x94, 0x6c, 0x79, 0x0a, 0x90, 0x6d, 0xe8, 0x64, 0xc2, 0x17, 0x79, 0xa6, 0x5b, 0xd2,
	0x48, 0x56, 0xd3, 0x34, 0xe5, 0xa9, 0xdd, 0x54, 0x9d, 0x22, 0x70, 0x77, 0xa1, 0x75, 0x44, 0xc3,
	0x84, 0xd8, 0xb0, 0x3e, 0xcf, 0xa3, 0xc8, 0x4f, 0x8b, 0x06, 0x0b, 0x48, 0x08, 0xb4, 0xc6, 0x69,
	0xa0, 0x26, 0x68, 0x79, 0x18, 0xbb, 0xbf, 0x0c, 0xe8, 0xd5, 0xfa, 0x94, 0xfc, 0x13, 0x16, 0x51,
	0x9e, 0x0b, 0xe4, 0x37, 0xbd, 0x02, 0x12, 0x17, 0x36, 0xc6, 0xb9, 0x58, 0xcc, 0xa5, 0xb9, 0x68,
	0xb0, 0xd4, 0x5d, 0xd5, 0x72, 0xe4, 0x31, 0xf4, 0xc6, 0x61, 0xc8, 0x2f, 0xe9, 0xd9, 0xbb, 0x94,
	0xe7, 0x89, 0xda, 0xb6, 0xe5, 0xd5, 0x93, 0x64, 0x00, 0x5b, 0x07, 0x0b, 0x3f, 0x8e, 0x69, 0x58,
	0x8a, 0xb5, 0x50, 0xec, 0x6a, 0x5a, 0x56, 0x6a, 0xaa, 0xfe, 0x92, 0xd9, 0x6d, 0x54, 0xbc, 0x9a,
	0x26, 0x6f, 0xc0, 0x3a, 0xa1, 0x51, 0x12, 0xfa, 0x82, 0x66, 0x76, 0x07, 0x4d, 0xf2, 0xf0, 0xfa,
	0x1a, 0x86, 0x65, 0x8d, 0x32, 0xc8, 0x8a, 0x43, 0x1e, 0x40, 0x6b, 0x41, 0xc3, 0xc4, 0x5e, 0xc7,
	0x15, 0x5a, 0xc8, 0x95, 0x13, 0xf5, 0x30, 0xed, 0xec, 0xc3, 0x66, 0x9d, 0xfb, 0x2f, 0x1e, 0x72,
	0xd7, 0xa1, 0x3d, 0x89, 0x12, 0xb1, 0x74, 0x7f, 0x18, 0xb0, 0x59, 0x58, 0x82, 0x7e, 0xcb, 0x69,
	0x26, 0xe4, 0xc4, 0xb5, 0x4d, 0x8b, 0x8d, 0x69, 0x28, 0x37, 0xe6, 0x57, 0x36, 0x26, 0x63, 0x79,
	0x79, 0xf3, 0x8c, 0xa6, 0x78, 0x79, 0x95, 0x01, 0x4a, 0x2c, 0x1d, 0x23, 0xe3, 0xe9, 0xa1, 0x1e,
	0xa7, 0x46, 0x05, 0x67, 0xc6, 0xe2, 0x73, 0xbb, 0xbd, 0xe2, 0x48, 0x8c, 0xa7, 0xab, 0x19, 0xda,
	0x1d, 0x7d, 0xba, 0x82, 0xe4, 0x3e, 0x58, 0x3a, 0x9c, 0x1e, 0xe2, 0x54, 0x2c, 0x6f, 0x95, 0x20,
	0x7d, 0xe8, 0x6a, 0x80, 0xb2, 0x26, 0x7e, 0xaf, 0xa6, 0x64, 0xf7, 0x2c, 0x9b, 0xbe, 0xb7, 0xad,
	0x7e, 0x63, 0x60, 0x7a, 0x18, 0xaf, 0x9c, 0x0e, 0x15, 0xa7, 0xbb, 0xbb, 0x60, 0xce, 0x78, 0xa0,
	0xa6, 0x7a, 0xf3, 0x5d, 0x20, 0xd0, 0x0a, 0x59, 0x5c, 0x0c, 0x16, 0x63, 0x77, 0x0f, 0x7a, 0x13,
	0x69, 0xfd, 0xbf, 0x50, 0xcb, 0xeb, 0x62, 0x54, 0xae, 0xcb, 0x68, 0x06, 0x1b, 0xb5, 0x97, 0x72,
	0x1f, 0x4c, 0x85, 0x69, 0x4a, 0xb6, 0x57, 0x8f, 0x4b, 0xb5, 0xc6, 0xa9, 0xe4, 0xab, 0xcf, 0xa3,
	0xbb, 0x36, 0xfa, 0xde, 0x80, 0x2d, 0xbd, 0xd5, 0x63, 0x96, 0x50, 0xd9, 0x1e, 0x19, 0xcb, 0x9b,
	0xa5, 0x14, 0x91, 0x42, 0xee, 0xdd, 0xf2, 0x66, 0x39, 0x77, 0xf0, 0x43, 0xdd, 0x15, 0xee, 0xda,
	0xf3, 0x06, 0xd9, 0x81, 0x8e, 0x7e, 0x21, 0x48, 0xb5, 0x44, 0xe5, 0x1c, 0xc0, 0x9c, 0xb2, 0xd5,
	0xda, 0x88, 0x82, 0x35, 0xe3, 0xc1, 0xa7, 0x94, 0xc9, 0x5f, 0xb0, 0x03, 0xd6, 0x07, 0x7a, 0xa9,
	0x41, 0x0f, 0xeb, 0x8a, 0x29, 0xd5, 0x69, 0x83, 0x06, 0x79, 0x06, 0xe6, 0x9c, 0x0a, 0x9c, 0xa4,
	0x3e, 0xa6, 0x36, 0xd5, 0x7a, 0xfd, 0x69, 0x07, 0xff, 0x72, 0x5e, 0xfc, 0x0e, 0x00, 0x00, 0xff,
	0xff, 0x12, 0x56, 0xa0, 0x58, 0x7f, 0x06, 0x00, 0x00,
}
