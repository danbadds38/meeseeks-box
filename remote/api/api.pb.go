// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	AgentRegistration
	AgentPrivateToken
	AgentConfiguration
	CommandFinish
	Help
	RemoteCommand
	Empty
	CommandRequest
	LogEntry
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AgentRegistration struct {
	Token    string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
	Hostname string `protobuf:"bytes,2,opt,name=Hostname" json:"Hostname,omitempty"`
}

func (m *AgentRegistration) Reset()                    { *m = AgentRegistration{} }
func (m *AgentRegistration) String() string            { return proto.CompactTextString(m) }
func (*AgentRegistration) ProtoMessage()               {}
func (*AgentRegistration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AgentRegistration) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AgentRegistration) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

type AgentPrivateToken struct {
	Token string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
}

func (m *AgentPrivateToken) Reset()                    { *m = AgentPrivateToken{} }
func (m *AgentPrivateToken) String() string            { return proto.CompactTextString(m) }
func (*AgentPrivateToken) ProtoMessage()               {}
func (*AgentPrivateToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AgentPrivateToken) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type AgentConfiguration struct {
	Token    string                    `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
	Labels   map[string]string         `protobuf:"bytes,3,rep,name=Labels" json:"Labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Commands map[string]*RemoteCommand `protobuf:"bytes,2,rep,name=commands" json:"commands,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AgentConfiguration) Reset()                    { *m = AgentConfiguration{} }
func (m *AgentConfiguration) String() string            { return proto.CompactTextString(m) }
func (*AgentConfiguration) ProtoMessage()               {}
func (*AgentConfiguration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AgentConfiguration) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AgentConfiguration) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *AgentConfiguration) GetCommands() map[string]*RemoteCommand {
	if m != nil {
		return m.Commands
	}
	return nil
}

type CommandFinish struct {
	JobID  uint64 `protobuf:"varint,1,opt,name=jobID" json:"jobID,omitempty"`
	Status string `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Error  string `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
}

func (m *CommandFinish) Reset()                    { *m = CommandFinish{} }
func (m *CommandFinish) String() string            { return proto.CompactTextString(m) }
func (*CommandFinish) ProtoMessage()               {}
func (*CommandFinish) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CommandFinish) GetJobID() uint64 {
	if m != nil {
		return m.JobID
	}
	return 0
}

func (m *CommandFinish) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *CommandFinish) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Help struct {
	Summary string   `protobuf:"bytes,1,opt,name=Summary" json:"Summary,omitempty"`
	Args    []string `protobuf:"bytes,2,rep,name=Args" json:"Args,omitempty"`
}

func (m *Help) Reset()                    { *m = Help{} }
func (m *Help) String() string            { return proto.CompactTextString(m) }
func (*Help) ProtoMessage()               {}
func (*Help) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Help) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *Help) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

type RemoteCommand struct {
	AuthStrategy     string            `protobuf:"bytes,1,opt,name=AuthStrategy" json:"AuthStrategy,omitempty"`
	Timeout          int64             `protobuf:"varint,2,opt,name=Timeout" json:"Timeout,omitempty"`
	Help             *Help             `protobuf:"bytes,3,opt,name=help" json:"help,omitempty"`
	AuthorizedGroups []string          `protobuf:"bytes,4,rep,name=AuthorizedGroups" json:"AuthorizedGroups,omitempty"`
	Templates        map[string]string `protobuf:"bytes,5,rep,name=Templates" json:"Templates,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *RemoteCommand) Reset()                    { *m = RemoteCommand{} }
func (m *RemoteCommand) String() string            { return proto.CompactTextString(m) }
func (*RemoteCommand) ProtoMessage()               {}
func (*RemoteCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RemoteCommand) GetAuthStrategy() string {
	if m != nil {
		return m.AuthStrategy
	}
	return ""
}

func (m *RemoteCommand) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RemoteCommand) GetHelp() *Help {
	if m != nil {
		return m.Help
	}
	return nil
}

func (m *RemoteCommand) GetAuthorizedGroups() []string {
	if m != nil {
		return m.AuthorizedGroups
	}
	return nil
}

func (m *RemoteCommand) GetTemplates() map[string]string {
	if m != nil {
		return m.Templates
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type CommandRequest struct {
	Command     string   `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
	Args        []string `protobuf:"bytes,2,rep,name=args" json:"args,omitempty"`
	Username    string   `protobuf:"bytes,3,opt,name=username" json:"username,omitempty"`
	UserID      string   `protobuf:"bytes,4,opt,name=userID" json:"userID,omitempty"`
	UserLink    string   `protobuf:"bytes,5,opt,name=userLink" json:"userLink,omitempty"`
	Channel     string   `protobuf:"bytes,6,opt,name=channel" json:"channel,omitempty"`
	ChannelID   string   `protobuf:"bytes,7,opt,name=channelID" json:"channelID,omitempty"`
	ChannelLink string   `protobuf:"bytes,8,opt,name=channelLink" json:"channelLink,omitempty"`
	IsIM        bool     `protobuf:"varint,9,opt,name=isIM" json:"isIM,omitempty"`
	JobID       uint64   `protobuf:"varint,10,opt,name=jobID" json:"jobID,omitempty"`
}

func (m *CommandRequest) Reset()                    { *m = CommandRequest{} }
func (m *CommandRequest) String() string            { return proto.CompactTextString(m) }
func (*CommandRequest) ProtoMessage()               {}
func (*CommandRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CommandRequest) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *CommandRequest) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *CommandRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *CommandRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *CommandRequest) GetUserLink() string {
	if m != nil {
		return m.UserLink
	}
	return ""
}

func (m *CommandRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *CommandRequest) GetChannelID() string {
	if m != nil {
		return m.ChannelID
	}
	return ""
}

func (m *CommandRequest) GetChannelLink() string {
	if m != nil {
		return m.ChannelLink
	}
	return ""
}

func (m *CommandRequest) GetIsIM() bool {
	if m != nil {
		return m.IsIM
	}
	return false
}

func (m *CommandRequest) GetJobID() uint64 {
	if m != nil {
		return m.JobID
	}
	return 0
}

type LogEntry struct {
	JobID uint64 `protobuf:"varint,1,opt,name=jobID" json:"jobID,omitempty"`
	Line  string `protobuf:"bytes,2,opt,name=line" json:"line,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *LogEntry) GetJobID() uint64 {
	if m != nil {
		return m.JobID
	}
	return 0
}

func (m *LogEntry) GetLine() string {
	if m != nil {
		return m.Line
	}
	return ""
}

func init() {
	proto.RegisterType((*AgentRegistration)(nil), "api.AgentRegistration")
	proto.RegisterType((*AgentPrivateToken)(nil), "api.AgentPrivateToken")
	proto.RegisterType((*AgentConfiguration)(nil), "api.AgentConfiguration")
	proto.RegisterType((*CommandFinish)(nil), "api.CommandFinish")
	proto.RegisterType((*Help)(nil), "api.Help")
	proto.RegisterType((*RemoteCommand)(nil), "api.RemoteCommand")
	proto.RegisterType((*Empty)(nil), "api.Empty")
	proto.RegisterType((*CommandRequest)(nil), "api.CommandRequest")
	proto.RegisterType((*LogEntry)(nil), "api.LogEntry")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Registration service

type RegistrationClient interface {
	Register(ctx context.Context, in *AgentRegistration, opts ...grpc.CallOption) (*AgentPrivateToken, error)
}

type registrationClient struct {
	cc *grpc.ClientConn
}

func NewRegistrationClient(cc *grpc.ClientConn) RegistrationClient {
	return &registrationClient{cc}
}

func (c *registrationClient) Register(ctx context.Context, in *AgentRegistration, opts ...grpc.CallOption) (*AgentPrivateToken, error) {
	out := new(AgentPrivateToken)
	err := grpc.Invoke(ctx, "/api.Registration/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Registration service

type RegistrationServer interface {
	Register(context.Context, *AgentRegistration) (*AgentPrivateToken, error)
}

func RegisterRegistrationServer(s *grpc.Server, srv RegistrationServer) {
	s.RegisterService(&_Registration_serviceDesc, srv)
}

func _Registration_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistrationServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Registration/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistrationServer).Register(ctx, req.(*AgentRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

var _Registration_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Registration",
	HandlerType: (*RegistrationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Registration_Register_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// Client API for CommandPipeline service

type CommandPipelineClient interface {
	Select(ctx context.Context, in *AgentConfiguration, opts ...grpc.CallOption) (CommandPipeline_SelectClient, error)
	Finish(ctx context.Context, in *CommandFinish, opts ...grpc.CallOption) (*Empty, error)
}

type commandPipelineClient struct {
	cc *grpc.ClientConn
}

func NewCommandPipelineClient(cc *grpc.ClientConn) CommandPipelineClient {
	return &commandPipelineClient{cc}
}

func (c *commandPipelineClient) Select(ctx context.Context, in *AgentConfiguration, opts ...grpc.CallOption) (CommandPipeline_SelectClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CommandPipeline_serviceDesc.Streams[0], c.cc, "/api.CommandPipeline/Select", opts...)
	if err != nil {
		return nil, err
	}
	x := &commandPipelineSelectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CommandPipeline_SelectClient interface {
	Recv() (*CommandRequest, error)
	grpc.ClientStream
}

type commandPipelineSelectClient struct {
	grpc.ClientStream
}

func (x *commandPipelineSelectClient) Recv() (*CommandRequest, error) {
	m := new(CommandRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *commandPipelineClient) Finish(ctx context.Context, in *CommandFinish, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.CommandPipeline/Finish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CommandPipeline service

type CommandPipelineServer interface {
	Select(*AgentConfiguration, CommandPipeline_SelectServer) error
	Finish(context.Context, *CommandFinish) (*Empty, error)
}

func RegisterCommandPipelineServer(s *grpc.Server, srv CommandPipelineServer) {
	s.RegisterService(&_CommandPipeline_serviceDesc, srv)
}

func _CommandPipeline_Select_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AgentConfiguration)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CommandPipelineServer).Select(m, &commandPipelineSelectServer{stream})
}

type CommandPipeline_SelectServer interface {
	Send(*CommandRequest) error
	grpc.ServerStream
}

type commandPipelineSelectServer struct {
	grpc.ServerStream
}

func (x *commandPipelineSelectServer) Send(m *CommandRequest) error {
	return x.ServerStream.SendMsg(m)
}

func _CommandPipeline_Finish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandFinish)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandPipelineServer).Finish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CommandPipeline/Finish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandPipelineServer).Finish(ctx, req.(*CommandFinish))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommandPipeline_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.CommandPipeline",
	HandlerType: (*CommandPipelineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Finish",
			Handler:    _CommandPipeline_Finish_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Select",
			Handler:       _CommandPipeline_Select_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

// Client API for CommandLogger service

type CommandLoggerClient interface {
	Append(ctx context.Context, opts ...grpc.CallOption) (CommandLogger_AppendClient, error)
}

type commandLoggerClient struct {
	cc *grpc.ClientConn
}

func NewCommandLoggerClient(cc *grpc.ClientConn) CommandLoggerClient {
	return &commandLoggerClient{cc}
}

func (c *commandLoggerClient) Append(ctx context.Context, opts ...grpc.CallOption) (CommandLogger_AppendClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CommandLogger_serviceDesc.Streams[0], c.cc, "/api.CommandLogger/Append", opts...)
	if err != nil {
		return nil, err
	}
	x := &commandLoggerAppendClient{stream}
	return x, nil
}

type CommandLogger_AppendClient interface {
	Send(*LogEntry) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type commandLoggerAppendClient struct {
	grpc.ClientStream
}

func (x *commandLoggerAppendClient) Send(m *LogEntry) error {
	return x.ClientStream.SendMsg(m)
}

func (x *commandLoggerAppendClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for CommandLogger service

type CommandLoggerServer interface {
	Append(CommandLogger_AppendServer) error
}

func RegisterCommandLoggerServer(s *grpc.Server, srv CommandLoggerServer) {
	s.RegisterService(&_CommandLogger_serviceDesc, srv)
}

func _CommandLogger_Append_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CommandLoggerServer).Append(&commandLoggerAppendServer{stream})
}

type CommandLogger_AppendServer interface {
	SendAndClose(*Empty) error
	Recv() (*LogEntry, error)
	grpc.ServerStream
}

type commandLoggerAppendServer struct {
	grpc.ServerStream
}

func (x *commandLoggerAppendServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *commandLoggerAppendServer) Recv() (*LogEntry, error) {
	m := new(LogEntry)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _CommandLogger_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.CommandLogger",
	HandlerType: (*CommandLoggerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Append",
			Handler:       _CommandLogger_Append_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 664 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xdd, 0x4e, 0xdb, 0x4a,
	0x10, 0x26, 0x89, 0x63, 0xe2, 0x09, 0x70, 0x38, 0x7b, 0x8e, 0x38, 0x96, 0x75, 0x2a, 0xa5, 0xae,
	0xaa, 0xa6, 0x5c, 0x44, 0x55, 0xca, 0x05, 0xa5, 0x48, 0x55, 0x04, 0xb4, 0x44, 0x4a, 0x55, 0xe4,
	0xf0, 0x02, 0x06, 0xa6, 0xce, 0x16, 0x7b, 0xd7, 0x5d, 0xaf, 0x91, 0xd2, 0xc7, 0xe8, 0x4d, 0xdf,
	0xa4, 0xcf, 0x57, 0xed, 0x8f, 0x13, 0x5b, 0x40, 0xa5, 0xde, 0xcd, 0x37, 0x3b, 0xdf, 0xb7, 0x9f,
	0x67, 0x66, 0x0d, 0x5e, 0x9c, 0xd3, 0x51, 0x2e, 0xb8, 0xe4, 0xa4, 0x13, 0xe7, 0x34, 0x3c, 0x83,
	0xbf, 0x27, 0x09, 0x32, 0x19, 0x61, 0x42, 0x0b, 0x29, 0x62, 0x49, 0x39, 0x23, 0xff, 0x42, 0xf7,
	0x92, 0xdf, 0x22, 0xf3, 0x5b, 0x83, 0xd6, 0xd0, 0x8b, 0x0c, 0x20, 0x01, 0xf4, 0xce, 0x79, 0x21,
	0x59, 0x9c, 0xa1, 0xdf, 0xd6, 0x07, 0x2b, 0x1c, 0xbe, 0xb4, 0x32, 0x17, 0x82, 0xde, 0xc5, 0x12,
	0x0d, 0xe1, 0x41, 0x99, 0xf0, 0x67, 0x1b, 0x88, 0xae, 0x3d, 0xe1, 0xec, 0x33, 0x4d, 0xca, 0xdf,
	0xde, 0xf9, 0x16, 0xdc, 0x59, 0x7c, 0x85, 0x69, 0xe1, 0x77, 0x06, 0x9d, 0x61, 0x7f, 0xfc, 0x6c,
	0xa4, 0xfc, 0xdf, 0xa7, 0x8f, 0x4c, 0xd5, 0x19, 0x93, 0x62, 0x19, 0x59, 0x0a, 0x99, 0x40, 0xef,
	0x9a, 0x67, 0x59, 0xcc, 0x6e, 0x0a, 0xbf, 0xad, 0xe9, 0xcf, 0x1f, 0xa3, 0x9f, 0xd8, 0x3a, 0x23,
	0xb0, 0xa2, 0x05, 0x6f, 0xa0, 0x5f, 0x53, 0x26, 0xbb, 0xd0, 0xb9, 0xc5, 0xa5, 0xb5, 0xa8, 0x42,
	0x65, 0xfb, 0x2e, 0x4e, 0xcb, 0xaa, 0x23, 0x06, 0x1c, 0xb5, 0x0f, 0x5b, 0xc1, 0x27, 0xd8, 0x6e,
	0xa8, 0x3e, 0x40, 0x1e, 0xd6, 0xc9, 0xfd, 0x31, 0xd1, 0xee, 0x22, 0xcc, 0xb8, 0x44, 0x4b, 0xad,
	0x09, 0x86, 0xf3, 0x95, 0xe0, 0x7b, 0xca, 0x68, 0xb1, 0x50, 0x77, 0x7f, 0xe1, 0x57, 0xd3, 0x53,
	0x2d, 0xe9, 0x44, 0x06, 0x90, 0x3d, 0x70, 0x0b, 0x19, 0xcb, 0xb2, 0xb0, 0x96, 0x2c, 0x52, 0xd5,
	0x28, 0x04, 0x17, 0x7e, 0xc7, 0x38, 0xd5, 0x20, 0x3c, 0x00, 0xe7, 0x1c, 0xd3, 0x9c, 0xf8, 0xb0,
	0x39, 0x2f, 0xb3, 0x2c, 0x16, 0x95, 0xc1, 0x0a, 0x12, 0x02, 0xce, 0x44, 0x24, 0xa6, 0x83, 0x5e,
	0xa4, 0xe3, 0xf0, 0x47, 0x1b, 0xb6, 0x1b, 0x3e, 0x49, 0x08, 0x5b, 0x93, 0x52, 0x2e, 0xe6, 0x6a,
	0x85, 0x30, 0xa9, 0x44, 0x1a, 0x39, 0x75, 0xc7, 0x25, 0xcd, 0x90, 0x97, 0x52, 0x5b, 0xeb, 0x44,
	0x15, 0x24, 0x4f, 0xc0, 0x59, 0x60, 0x9a, 0x6b, 0x6b, 0xfd, 0xb1, 0xa7, 0xfb, 0xa0, 0x6c, 0x45,
	0x3a, 0x4d, 0xf6, 0x61, 0x57, 0x09, 0x71, 0x41, 0xbf, 0xe1, 0xcd, 0x07, 0xc1, 0xcb, 0xbc, 0xf0,
	0x1d, 0x6d, 0xe7, 0x5e, 0x9e, 0xbc, 0x03, 0xef, 0x12, 0xb3, 0x3c, 0x8d, 0x25, 0x16, 0x7e, 0x57,
	0x4f, 0xfd, 0xe9, 0xfd, 0xbe, 0x8e, 0x56, 0x35, 0x66, 0xe2, 0x6b, 0x4e, 0x70, 0x0c, 0x3b, 0xcd,
	0xc3, 0x3f, 0x99, 0x7a, 0xb8, 0x09, 0xdd, 0xb3, 0x2c, 0x97, 0xcb, 0xf0, 0x7b, 0x1b, 0x76, 0xaa,
	0x21, 0xe2, 0xd7, 0x12, 0x0b, 0xa9, 0xbe, 0xdf, 0x2e, 0x56, 0xd5, 0x63, 0x0b, 0x55, 0x8f, 0xe3,
	0x5a, 0x8f, 0x55, 0xac, 0x9e, 0x5b, 0x59, 0xa0, 0xd0, 0xcf, 0xcd, 0x8c, 0x6c, 0x85, 0xd5, 0x8c,
	0x55, 0x3c, 0x3d, 0xf5, 0x1d, 0x33, 0x63, 0x83, 0x2a, 0xce, 0x8c, 0xb2, 0x5b, 0xbf, 0xbb, 0xe6,
	0x28, 0xac, 0x6f, 0x5f, 0xc4, 0x8c, 0x61, 0xea, 0xbb, 0xf6, 0x76, 0x03, 0xc9, 0xff, 0xe0, 0xd9,
	0x70, 0x7a, 0xea, 0x6f, 0xea, 0xb3, 0x75, 0x82, 0x0c, 0xa0, 0x6f, 0x81, 0x96, 0xed, 0xe9, 0xf3,
	0x7a, 0x4a, 0xb9, 0xa7, 0xc5, 0xf4, 0xa3, 0xef, 0x0d, 0x5a, 0xc3, 0x5e, 0xa4, 0xe3, 0xf5, 0x6e,
	0x42, 0x6d, 0x37, 0xc3, 0x03, 0xe8, 0xcd, 0x78, 0x62, 0xba, 0xfa, 0xf0, 0xf6, 0x12, 0x70, 0x52,
	0xca, 0xaa, 0xc6, 0xea, 0x78, 0x3c, 0x83, 0xad, 0xc6, 0xef, 0xe9, 0x18, 0x7a, 0x06, 0xa3, 0x20,
	0x7b, 0xeb, 0x17, 0x5d, 0xaf, 0x09, 0x6a, 0xf9, 0xfa, 0x3f, 0x29, 0xdc, 0x18, 0x2f, 0xe1, 0x2f,
	0x3b, 0x97, 0x0b, 0x9a, 0xa3, 0xba, 0x80, 0x1c, 0x81, 0x3b, 0xc7, 0x14, 0xaf, 0x25, 0xf9, 0xef,
	0x91, 0x1f, 0x44, 0xf0, 0x8f, 0x3e, 0x68, 0x0e, 0x34, 0xdc, 0x78, 0xd5, 0x22, 0xfb, 0xe0, 0xda,
	0xe7, 0x48, 0xea, 0x25, 0x26, 0x17, 0x80, 0xce, 0x99, 0x8d, 0xd8, 0x18, 0x1f, 0xae, 0x5e, 0xf0,
	0x8c, 0x27, 0x09, 0x0a, 0xf2, 0x02, 0xdc, 0x49, 0x9e, 0x23, 0xbb, 0x21, 0xdb, 0xba, 0xb0, 0x6a,
	0x4e, 0x93, 0x37, 0x6c, 0x5d, 0xb9, 0xfa, 0x97, 0xfd, 0xfa, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x74, 0x67, 0x1d, 0xdf, 0xbf, 0x05, 0x00, 0x00,
}
