// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api.proto

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	api.proto

It has these top-level messages:
	AgentRegistration
	AgentPrivateToken
	AgentConfiguration
	CommandFinish
	Help
	RemoteCommand
	Empty
	CommandRequest
	LogEntry
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type AgentRegistration struct {
	Token    string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
	Hostname string `protobuf:"bytes,2,opt,name=Hostname" json:"Hostname,omitempty"`
}

func (m *AgentRegistration) Reset()                    { *m = AgentRegistration{} }
func (m *AgentRegistration) String() string            { return proto.CompactTextString(m) }
func (*AgentRegistration) ProtoMessage()               {}
func (*AgentRegistration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AgentRegistration) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AgentRegistration) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

type AgentPrivateToken struct {
	Token string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
}

func (m *AgentPrivateToken) Reset()                    { *m = AgentPrivateToken{} }
func (m *AgentPrivateToken) String() string            { return proto.CompactTextString(m) }
func (*AgentPrivateToken) ProtoMessage()               {}
func (*AgentPrivateToken) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *AgentPrivateToken) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type AgentConfiguration struct {
	Token    string                    `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
	Labels   map[string]string         `protobuf:"bytes,3,rep,name=Labels" json:"Labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Commands map[string]*RemoteCommand `protobuf:"bytes,2,rep,name=commands" json:"commands,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *AgentConfiguration) Reset()                    { *m = AgentConfiguration{} }
func (m *AgentConfiguration) String() string            { return proto.CompactTextString(m) }
func (*AgentConfiguration) ProtoMessage()               {}
func (*AgentConfiguration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *AgentConfiguration) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AgentConfiguration) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *AgentConfiguration) GetCommands() map[string]*RemoteCommand {
	if m != nil {
		return m.Commands
	}
	return nil
}

type CommandFinish struct {
	JobID  uint64 `protobuf:"varint,1,opt,name=jobID" json:"jobID,omitempty"`
	Status string `protobuf:"bytes,2,opt,name=status" json:"status,omitempty"`
	Error  string `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
}

func (m *CommandFinish) Reset()                    { *m = CommandFinish{} }
func (m *CommandFinish) String() string            { return proto.CompactTextString(m) }
func (*CommandFinish) ProtoMessage()               {}
func (*CommandFinish) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CommandFinish) GetJobID() uint64 {
	if m != nil {
		return m.JobID
	}
	return 0
}

func (m *CommandFinish) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *CommandFinish) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Help struct {
	Summary string   `protobuf:"bytes,1,opt,name=Summary" json:"Summary,omitempty"`
	Args    []string `protobuf:"bytes,2,rep,name=Args" json:"Args,omitempty"`
}

func (m *Help) Reset()                    { *m = Help{} }
func (m *Help) String() string            { return proto.CompactTextString(m) }
func (*Help) ProtoMessage()               {}
func (*Help) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Help) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

func (m *Help) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

type RemoteCommand struct {
	Timeout         int64             `protobuf:"varint,1,opt,name=Timeout" json:"Timeout,omitempty"`
	AuthStrategy    string            `protobuf:"bytes,2,opt,name=AuthStrategy" json:"AuthStrategy,omitempty"`
	AllowedGroups   []string          `protobuf:"bytes,3,rep,name=AllowedGroups" json:"AllowedGroups,omitempty"`
	ChannelStrategy string            `protobuf:"bytes,4,opt,name=ChannelStrategy" json:"ChannelStrategy,omitempty"`
	AllowedChannels []string          `protobuf:"bytes,5,rep,name=AllowedChannels" json:"AllowedChannels,omitempty"`
	Templates       map[string]string `protobuf:"bytes,6,rep,name=Templates" json:"Templates,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Help            *Help             `protobuf:"bytes,7,opt,name=help" json:"help,omitempty"`
}

func (m *RemoteCommand) Reset()                    { *m = RemoteCommand{} }
func (m *RemoteCommand) String() string            { return proto.CompactTextString(m) }
func (*RemoteCommand) ProtoMessage()               {}
func (*RemoteCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *RemoteCommand) GetTimeout() int64 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *RemoteCommand) GetAuthStrategy() string {
	if m != nil {
		return m.AuthStrategy
	}
	return ""
}

func (m *RemoteCommand) GetAllowedGroups() []string {
	if m != nil {
		return m.AllowedGroups
	}
	return nil
}

func (m *RemoteCommand) GetChannelStrategy() string {
	if m != nil {
		return m.ChannelStrategy
	}
	return ""
}

func (m *RemoteCommand) GetAllowedChannels() []string {
	if m != nil {
		return m.AllowedChannels
	}
	return nil
}

func (m *RemoteCommand) GetTemplates() map[string]string {
	if m != nil {
		return m.Templates
	}
	return nil
}

func (m *RemoteCommand) GetHelp() *Help {
	if m != nil {
		return m.Help
	}
	return nil
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type CommandRequest struct {
	Command     string   `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
	Args        []string `protobuf:"bytes,2,rep,name=args" json:"args,omitempty"`
	Username    string   `protobuf:"bytes,3,opt,name=username" json:"username,omitempty"`
	UserID      string   `protobuf:"bytes,4,opt,name=userID" json:"userID,omitempty"`
	UserLink    string   `protobuf:"bytes,5,opt,name=userLink" json:"userLink,omitempty"`
	Channel     string   `protobuf:"bytes,6,opt,name=channel" json:"channel,omitempty"`
	ChannelID   string   `protobuf:"bytes,7,opt,name=channelID" json:"channelID,omitempty"`
	ChannelLink string   `protobuf:"bytes,8,opt,name=channelLink" json:"channelLink,omitempty"`
	IsIM        bool     `protobuf:"varint,9,opt,name=isIM" json:"isIM,omitempty"`
	JobID       uint64   `protobuf:"varint,10,opt,name=jobID" json:"jobID,omitempty"`
}

func (m *CommandRequest) Reset()                    { *m = CommandRequest{} }
func (m *CommandRequest) String() string            { return proto.CompactTextString(m) }
func (*CommandRequest) ProtoMessage()               {}
func (*CommandRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *CommandRequest) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *CommandRequest) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *CommandRequest) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *CommandRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *CommandRequest) GetUserLink() string {
	if m != nil {
		return m.UserLink
	}
	return ""
}

func (m *CommandRequest) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *CommandRequest) GetChannelID() string {
	if m != nil {
		return m.ChannelID
	}
	return ""
}

func (m *CommandRequest) GetChannelLink() string {
	if m != nil {
		return m.ChannelLink
	}
	return ""
}

func (m *CommandRequest) GetIsIM() bool {
	if m != nil {
		return m.IsIM
	}
	return false
}

func (m *CommandRequest) GetJobID() uint64 {
	if m != nil {
		return m.JobID
	}
	return 0
}

type LogEntry struct {
	JobID uint64 `protobuf:"varint,1,opt,name=jobID" json:"jobID,omitempty"`
	Line  string `protobuf:"bytes,2,opt,name=line" json:"line,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *LogEntry) GetJobID() uint64 {
	if m != nil {
		return m.JobID
	}
	return 0
}

func (m *LogEntry) GetLine() string {
	if m != nil {
		return m.Line
	}
	return ""
}

func init() {
	proto.RegisterType((*AgentRegistration)(nil), "api.AgentRegistration")
	proto.RegisterType((*AgentPrivateToken)(nil), "api.AgentPrivateToken")
	proto.RegisterType((*AgentConfiguration)(nil), "api.AgentConfiguration")
	proto.RegisterType((*CommandFinish)(nil), "api.CommandFinish")
	proto.RegisterType((*Help)(nil), "api.Help")
	proto.RegisterType((*RemoteCommand)(nil), "api.RemoteCommand")
	proto.RegisterType((*Empty)(nil), "api.Empty")
	proto.RegisterType((*CommandRequest)(nil), "api.CommandRequest")
	proto.RegisterType((*LogEntry)(nil), "api.LogEntry")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Registration service

type RegistrationClient interface {
	Register(ctx context.Context, in *AgentRegistration, opts ...grpc.CallOption) (*AgentPrivateToken, error)
}

type registrationClient struct {
	cc *grpc.ClientConn
}

func NewRegistrationClient(cc *grpc.ClientConn) RegistrationClient {
	return &registrationClient{cc}
}

func (c *registrationClient) Register(ctx context.Context, in *AgentRegistration, opts ...grpc.CallOption) (*AgentPrivateToken, error) {
	out := new(AgentPrivateToken)
	err := grpc.Invoke(ctx, "/api.Registration/Register", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Registration service

type RegistrationServer interface {
	Register(context.Context, *AgentRegistration) (*AgentPrivateToken, error)
}

func RegisterRegistrationServer(s *grpc.Server, srv RegistrationServer) {
	s.RegisterService(&_Registration_serviceDesc, srv)
}

func _Registration_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegistrationServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.Registration/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegistrationServer).Register(ctx, req.(*AgentRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

var _Registration_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.Registration",
	HandlerType: (*RegistrationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Registration_Register_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api.proto",
}

// Client API for CommandPipeline service

type CommandPipelineClient interface {
	RegisterAgent(ctx context.Context, in *AgentConfiguration, opts ...grpc.CallOption) (CommandPipeline_RegisterAgentClient, error)
	Finish(ctx context.Context, in *CommandFinish, opts ...grpc.CallOption) (*Empty, error)
}

type commandPipelineClient struct {
	cc *grpc.ClientConn
}

func NewCommandPipelineClient(cc *grpc.ClientConn) CommandPipelineClient {
	return &commandPipelineClient{cc}
}

func (c *commandPipelineClient) RegisterAgent(ctx context.Context, in *AgentConfiguration, opts ...grpc.CallOption) (CommandPipeline_RegisterAgentClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CommandPipeline_serviceDesc.Streams[0], c.cc, "/api.CommandPipeline/RegisterAgent", opts...)
	if err != nil {
		return nil, err
	}
	x := &commandPipelineRegisterAgentClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CommandPipeline_RegisterAgentClient interface {
	Recv() (*CommandRequest, error)
	grpc.ClientStream
}

type commandPipelineRegisterAgentClient struct {
	grpc.ClientStream
}

func (x *commandPipelineRegisterAgentClient) Recv() (*CommandRequest, error) {
	m := new(CommandRequest)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *commandPipelineClient) Finish(ctx context.Context, in *CommandFinish, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/api.CommandPipeline/Finish", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for CommandPipeline service

type CommandPipelineServer interface {
	RegisterAgent(*AgentConfiguration, CommandPipeline_RegisterAgentServer) error
	Finish(context.Context, *CommandFinish) (*Empty, error)
}

func RegisterCommandPipelineServer(s *grpc.Server, srv CommandPipelineServer) {
	s.RegisterService(&_CommandPipeline_serviceDesc, srv)
}

func _CommandPipeline_RegisterAgent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AgentConfiguration)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CommandPipelineServer).RegisterAgent(m, &commandPipelineRegisterAgentServer{stream})
}

type CommandPipeline_RegisterAgentServer interface {
	Send(*CommandRequest) error
	grpc.ServerStream
}

type commandPipelineRegisterAgentServer struct {
	grpc.ServerStream
}

func (x *commandPipelineRegisterAgentServer) Send(m *CommandRequest) error {
	return x.ServerStream.SendMsg(m)
}

func _CommandPipeline_Finish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandFinish)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandPipelineServer).Finish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/api.CommandPipeline/Finish",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandPipelineServer).Finish(ctx, req.(*CommandFinish))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommandPipeline_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.CommandPipeline",
	HandlerType: (*CommandPipelineServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Finish",
			Handler:    _CommandPipeline_Finish_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RegisterAgent",
			Handler:       _CommandPipeline_RegisterAgent_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api.proto",
}

// Client API for CommandLogger service

type CommandLoggerClient interface {
	NewAppender(ctx context.Context, opts ...grpc.CallOption) (CommandLogger_NewAppenderClient, error)
}

type commandLoggerClient struct {
	cc *grpc.ClientConn
}

func NewCommandLoggerClient(cc *grpc.ClientConn) CommandLoggerClient {
	return &commandLoggerClient{cc}
}

func (c *commandLoggerClient) NewAppender(ctx context.Context, opts ...grpc.CallOption) (CommandLogger_NewAppenderClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CommandLogger_serviceDesc.Streams[0], c.cc, "/api.CommandLogger/NewAppender", opts...)
	if err != nil {
		return nil, err
	}
	x := &commandLoggerNewAppenderClient{stream}
	return x, nil
}

type CommandLogger_NewAppenderClient interface {
	Send(*LogEntry) error
	CloseAndRecv() (*Empty, error)
	grpc.ClientStream
}

type commandLoggerNewAppenderClient struct {
	grpc.ClientStream
}

func (x *commandLoggerNewAppenderClient) Send(m *LogEntry) error {
	return x.ClientStream.SendMsg(m)
}

func (x *commandLoggerNewAppenderClient) CloseAndRecv() (*Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for CommandLogger service

type CommandLoggerServer interface {
	NewAppender(CommandLogger_NewAppenderServer) error
}

func RegisterCommandLoggerServer(s *grpc.Server, srv CommandLoggerServer) {
	s.RegisterService(&_CommandLogger_serviceDesc, srv)
}

func _CommandLogger_NewAppender_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CommandLoggerServer).NewAppender(&commandLoggerNewAppenderServer{stream})
}

type CommandLogger_NewAppenderServer interface {
	SendAndClose(*Empty) error
	Recv() (*LogEntry, error)
	grpc.ServerStream
}

type commandLoggerNewAppenderServer struct {
	grpc.ServerStream
}

func (x *commandLoggerNewAppenderServer) SendAndClose(m *Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *commandLoggerNewAppenderServer) Recv() (*LogEntry, error) {
	m := new(LogEntry)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _CommandLogger_serviceDesc = grpc.ServiceDesc{
	ServiceName: "api.CommandLogger",
	HandlerType: (*CommandLoggerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NewAppender",
			Handler:       _CommandLogger_NewAppender_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "api.proto",
}

func init() { proto.RegisterFile("api.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 690 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xeb, 0x6e, 0xd3, 0x4a,
	0x10, 0xae, 0x73, 0x6b, 0x3c, 0x69, 0xda, 0x73, 0xf6, 0x1c, 0x15, 0xcb, 0x02, 0x29, 0x18, 0x90,
	0x02, 0x42, 0x11, 0x0a, 0xfd, 0xc1, 0xa5, 0x08, 0x59, 0x6d, 0xa1, 0x91, 0x02, 0x54, 0x6e, 0x5f,
	0xc0, 0xa5, 0x83, 0x63, 0x6a, 0xef, 0x9a, 0xf5, 0xba, 0x55, 0xfe, 0xf1, 0x0c, 0x3c, 0x0c, 0x6f,
	0xc4, 0x7b, 0xa0, 0xbd, 0xd8, 0xb1, 0x7b, 0x41, 0xe2, 0xdf, 0x7c, 0xe3, 0xf9, 0xbe, 0x1d, 0xcd,
	0x7c, 0xbb, 0x06, 0x3b, 0xcc, 0xe2, 0x49, 0xc6, 0x99, 0x60, 0xa4, 0x1d, 0x66, 0xb1, 0x77, 0x00,
	0xff, 0xfa, 0x11, 0x52, 0x11, 0x60, 0x14, 0xe7, 0x82, 0x87, 0x22, 0x66, 0x94, 0xfc, 0x0f, 0xdd,
	0x13, 0x76, 0x8e, 0xd4, 0xb1, 0x46, 0xd6, 0xd8, 0x0e, 0x34, 0x20, 0x2e, 0xf4, 0x0f, 0x59, 0x2e,
	0x68, 0x98, 0xa2, 0xd3, 0x52, 0x1f, 0x2a, 0xec, 0x3d, 0x36, 0x32, 0x47, 0x3c, 0xbe, 0x08, 0x05,
	0x6a, 0xc2, 0x8d, 0x32, 0xde, 0xcf, 0x16, 0x10, 0x55, 0xbb, 0xc7, 0xe8, 0x97, 0x38, 0x2a, 0xfe,
	0x78, 0xe6, 0x6b, 0xe8, 0xcd, 0xc3, 0x53, 0x4c, 0x72, 0xa7, 0x3d, 0x6a, 0x8f, 0x07, 0xd3, 0x07,
	0x13, 0xd9, 0xff, 0x75, 0xfa, 0x44, 0x57, 0x1d, 0x50, 0xc1, 0x97, 0x81, 0xa1, 0x10, 0x1f, 0xfa,
	0x9f, 0x59, 0x9a, 0x86, 0xf4, 0x2c, 0x77, 0x5a, 0x8a, 0xfe, 0xe8, 0x36, 0xfa, 0x9e, 0xa9, 0xd3,
	0x02, 0x15, 0xcd, 0x7d, 0x09, 0x83, 0x9a, 0x32, 0xf9, 0x07, 0xda, 0xe7, 0xb8, 0x34, 0x2d, 0xca,
	0x50, 0xb6, 0x7d, 0x11, 0x26, 0x45, 0x39, 0x11, 0x0d, 0x5e, 0xb5, 0x5e, 0x58, 0xee, 0x27, 0x18,
	0x36, 0x54, 0x6f, 0x20, 0x8f, 0xeb, 0xe4, 0xc1, 0x94, 0xa8, 0xee, 0x02, 0x4c, 0x99, 0x40, 0x43,
	0xad, 0x09, 0x7a, 0xc7, 0x95, 0xe0, 0xbb, 0x98, 0xc6, 0xf9, 0x42, 0x9e, 0xfd, 0x95, 0x9d, 0xce,
	0xf6, 0x95, 0x64, 0x27, 0xd0, 0x80, 0x6c, 0x43, 0x2f, 0x17, 0xa1, 0x28, 0x72, 0xd3, 0x92, 0x41,
	0xb2, 0x1a, 0x39, 0x67, 0xdc, 0x69, 0xeb, 0x4e, 0x15, 0xf0, 0x76, 0xa0, 0x73, 0x88, 0x49, 0x46,
	0x1c, 0x58, 0x3f, 0x2e, 0xd2, 0x34, 0xe4, 0x65, 0x83, 0x25, 0x24, 0x04, 0x3a, 0x3e, 0x8f, 0xf4,
	0x04, 0xed, 0x40, 0xc5, 0xde, 0xaf, 0x16, 0x0c, 0x1b, 0x7d, 0x4a, 0xfe, 0x49, 0x9c, 0x22, 0x2b,
	0x84, 0xe2, 0xb7, 0x83, 0x12, 0x12, 0x0f, 0x36, 0xfc, 0x42, 0x2c, 0x8e, 0xa5, 0xb9, 0x30, 0x5a,
	0x9a, 0xae, 0x1a, 0x39, 0xf2, 0x10, 0x86, 0x7e, 0x92, 0xb0, 0x4b, 0x3c, 0x7b, 0xcf, 0x59, 0x91,
	0xe9, 0x6d, 0xdb, 0x41, 0x33, 0x49, 0xc6, 0xb0, 0xb5, 0xb7, 0x08, 0x29, 0xc5, 0xa4, 0x12, 0xeb,
	0x28, 0xb1, 0xab, 0x69, 0x59, 0x69, 0xa8, 0xe6, 0x4b, 0xee, 0x74, 0x95, 0xe2, 0xd5, 0x34, 0x79,
	0x0b, 0xf6, 0x09, 0xa6, 0x59, 0x12, 0x0a, 0xcc, 0x9d, 0x9e, 0x32, 0xc9, 0xfd, 0xeb, 0x6b, 0x98,
	0x54, 0x35, 0xda, 0x20, 0x2b, 0x0e, 0xb9, 0x07, 0x9d, 0x05, 0x26, 0x99, 0xb3, 0xae, 0x56, 0x68,
	0x2b, 0xae, 0x9c, 0x68, 0xa0, 0xd2, 0xee, 0x2e, 0x6c, 0x36, 0xb9, 0x7f, 0xe3, 0x21, 0x6f, 0x1d,
	0xba, 0x07, 0x69, 0x26, 0x96, 0xde, 0x8f, 0x16, 0x6c, 0x96, 0x96, 0xc0, 0x6f, 0x05, 0xe6, 0x42,
	0x4e, 0xdc, 0xd8, 0xb4, 0xdc, 0x98, 0x81, 0x72, 0x63, 0x61, 0x6d, 0x63, 0x32, 0x96, 0x97, 0xb7,
	0xc8, 0x91, 0xab, 0xcb, 0xab, 0x0d, 0x50, 0x61, 0xe9, 0x18, 0x19, 0xcf, 0xf6, 0xcd, 0x38, 0x0d,
	0x2a, 0x39, 0xf3, 0x98, 0x9e, 0x3b, 0xdd, 0x15, 0x47, 0x62, 0x75, 0xba, 0x9e, 0xa1, 0xd3, 0x33,
	0xa7, 0x6b, 0x48, 0xee, 0x82, 0x6d, 0xc2, 0xd9, 0xbe, 0x9a, 0x8a, 0x1d, 0xac, 0x12, 0x64, 0x04,
	0x03, 0x03, 0x94, 0x6c, 0x5f, 0x7d, 0xaf, 0xa7, 0x64, 0xf7, 0x71, 0x3e, 0xfb, 0xe0, 0xd8, 0x23,
	0x6b, 0xdc, 0x0f, 0x54, 0xbc, 0x72, 0x3a, 0xd4, 0x9c, 0xee, 0xed, 0x40, 0x7f, 0xce, 0x22, 0x3d,
	0xd5, 0x9b, 0xef, 0x02, 0x81, 0x4e, 0x12, 0xd3, 0x72, 0xb0, 0x2a, 0x9e, 0xce, 0x61, 0xa3, 0xf1,
	0xd8, 0xed, 0x42, 0x5f, 0x63, 0xe4, 0x64, 0x7b, 0xf5, 0x3e, 0xd4, 0x6b, 0xdc, 0x5a, 0xbe, 0xfe,
	0xc2, 0x79, 0x6b, 0xd3, 0xef, 0x16, 0x6c, 0x99, 0xc5, 0x1c, 0xc5, 0x19, 0xca, 0x13, 0x88, 0x2f,
	0x2f, 0x87, 0x56, 0x54, 0x14, 0x72, 0xe7, 0x96, 0x67, 0xc7, 0xfd, 0x4f, 0x7d, 0x68, 0x2e, 0xd6,
	0x5b, 0x7b, 0x66, 0x91, 0x27, 0xd0, 0x33, 0x97, 0x9c, 0xd4, 0x4b, 0x74, 0xce, 0x05, 0x95, 0xd3,
	0xce, 0x58, 0x9b, 0xbe, 0xa9, 0xde, 0x85, 0x39, 0x8b, 0x22, 0xe4, 0xe4, 0x29, 0x0c, 0x3e, 0xe2,
	0xa5, 0x9f, 0x65, 0x48, 0xcf, 0x90, 0x93, 0xa1, 0xaa, 0x2e, 0x27, 0xd5, 0x24, 0x8f, 0xad, 0xd3,
	0x9e, 0xfa, 0x1b, 0x3c, 0xff, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x27, 0x23, 0x45, 0x88, 0x1a, 0x06,
	0x00, 0x00,
}
